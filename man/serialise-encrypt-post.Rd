% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/serialise-encrypt-post.R
\name{serialise-encrypt-post}
\alias{serialise-encrypt-post}
\alias{serialise}
\alias{deserialise}
\alias{encrypt}
\alias{decrypt}
\alias{post_data}
\alias{create_json_body}
\alias{read_json_body}
\title{Serialise, Compress, Encrypt, and Transfer Data}
\usage{
serialise(object, compress = TRUE, as_character = TRUE)

deserialise(object, decompress = TRUE)

encrypt(x, key = Sys.getenv("mmbi_epi_encryption_key"), as_character = TRUE)

decrypt(x, key = Sys.getenv("mmbi_epi_encryption_key"), as_character = TRUE)

post_data(
  object,
  url,
  authorization_header = NULL,
  compress = TRUE,
  encrypt = TRUE,
  key = Sys.getenv("mmbi_epi_encryption_key")
)

create_json_body(
  object,
  compress = TRUE,
  encrypt = TRUE,
  key = Sys.getenv("mmbi_epi_encryption_key")
)

read_json_body(
  object,
  decompress = TRUE,
  decrypt = NULL,
  key = Sys.getenv("mmbi_epi_encryption_key")
)
}
\arguments{
\item{object}{Any object of any size, preferably a data set}

\item{compress, decompress}{Should the serialised object be compressed/decompressed? At least allowed: \code{"gzip"} (or \code{TRUE}), \code{"bzip2"}, \code{"xz"}, see \code{\link[base:memCompress]{base::memCompress()}}. Use \code{FALSE} to not compress/decompress.}

\item{as_character}{A logical to indicate whether output should be converted to a \link{character} string. Note that these have a limit of 2,147,483,647 characters (= \eqn{2^{31} - 1} bytes = ~2 GB in object size), so a \link{raw} vector should be used for very large inputs (i.e., \code{as_character = FALSE}).}

\item{x}{A \link{raw} or \link{character} vector}

\item{key}{A character to be used as the encryption key. Internally, this is converted using \code{\link[openssl:hash]{openssl::sha256()}} to ensure a raw high-entropy key of length \code{32}, suitable for AES-GCM encryption. The default is the \link[=Sys.getenv]{system environment variable}: \code{mmbi_epi_encryption_key}.}

\item{url}{A character string specifying the target URL for the HTTP POST request. Must include the full scheme (e.g., \code{"https://"} or \code{"http://"}), hostname, and path.}

\item{authorization_header}{A character string specifying the value of the \code{Authorization} header to include in the POST request, e.g. \code{"Bearer <token>"}. Use \code{NULL} to omit the header.}

\item{encrypt, decrypt}{Should the serialised object be encrypted/decrypted? This applies AES-GCM via \code{\link[openssl:aes_cbc]{openssl::aes_gcm_encrypt()}}, providing authenticated encryption. This guarantees both confidentiality and integrity: the file cannot be read without the correct \code{key}, and any tampering will be detected automatically during decryption. The initialization vector (iv) will be a length-12 random \link{raw} vector.}
}
\description{
Securely serialise, compress, encrypt, and transfer any R object with full attribute preservation and cross-platform JSON compatibility.
}
\details{
\subsection{Serialisation}{

\code{\link[=serialise]{serialise()}} converts an arbitrary R object into a transportable
format by wrapping it with metadata, including:
\itemize{
\item Object-level attributes (via \code{attributes()}),
\item For data frames: per-column attributes, including class (e.g., \code{factor},
\code{Date}, \code{POSIXct}), levels, and time zone information.
}

The wrapped structure is then converted to JSON using \code{\link[jsonlite:fromJSON]{jsonlite::toJSON()}},
with consistent handling of \code{NULL}s, \code{NA}s, and timestamps. This structure
allows accurate reconstruction of the original object, including attributes,
when passed through \code{\link[=deserialise]{deserialise()}}.

The resulting JSON representation is portable and can be decoded in non-R
environments such as Python. This method avoids using base R \code{serialize()},
which output is R-specific and unreadable elsewhere.
}

\subsection{Compression}{

If \code{compress = TRUE}, \code{\link[=serialise]{serialise()}} uses gzip compression
(\code{memCompress(type = "gzip")}) by default. Other algorithms ("bzip2",
"xz") are supported. Compression reduces payload size but requires the same
algorithm to be used for decompression. In \code{\link[=deserialise]{deserialise()}} and
\code{\link[=read_json_body]{read_json_body()}} the corresponding \code{\link[=memDecompress]{memDecompress()}} step is
applied when \code{decompress = TRUE}.
}

\subsection{Encryption (AES-GCM)}{

\code{\link[=encrypt]{encrypt()}} applies AES in Galois/Counter Mode (GCM) via
\code{\link[openssl:aes_cbc]{openssl::aes_gcm_encrypt()}}. AES-GCM provides authenticated encryption:
it guarantees \emph{confidentiality} (content is unreadable without the key)
and \emph{integrity} (any bit-level modification is detected during
decryption). A fresh 12-byte initialisation vector (IV) is generated for each
encryption (\code{rand_bytes(12)}), which is required for security. Because
the IV is random/unique per call, the ciphertext differs across runs even for
identical inputs; this is expected and desirable. The IV itself is not
secret and is packaged alongside the ciphertext so decryption can succeed.
}

\subsection{Transport}{

\code{\link[=post_data]{post_data()}} sends the JSON body with \code{\link[httr:POST]{httr::POST()}} using
\code{encode = "json"} and sets the HTTP \code{Authorization} header if you
pass one (for example a bearer token). The receiving service can be any
stack that can: (1) parse JSON, (2) base64-decode
fields, (3) perform AES-GCM decryption with the same key and IV, (4) gzip
decompress, and (5) deserialise JSON strings.
}

\subsection{Read in R}{

To decrypt, decompress, and process in R at the receiving side, do:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{library(mmbi.epi)

# assuming `json_payload` is received
read_json_body(decompress = TRUE, decrypt = TRUE, key = "my-key")
}\if{html}{\out{</div>}}
}

\subsection{Read in Python}{

To decrypt, decompress, and process in Python at the receiving side, do:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{import json, base64, gzip
import pandas as pd
from Crypto.Cipher import AES
from Crypto.Hash import SHA256

# assuming `json_payload` is received
payload = json.loads(json_payload)
ct = base64.b64decode(payload["data"])
iv = base64.b64decode(payload["iv"])

# key derivation (same as openssl::sha256 in R)
key = SHA256.new(b"my-key").digest()

# decrypt (AES-GCM)
cipher = AES.new(key, AES.MODE_GCM, nonce=iv)
decrypted = cipher.decrypt(ct)

# decompress and parse
decompressed = gzip.decompress(decrypted)
df = pd.read_json(decompressed.decode("utf-8"))
}\if{html}{\out{</div>}}
}
}
\examples{
# SERIALISATION AND ENCRYPTION -----------------------------------------

# in essence:
iris2 <- iris |> serialise() |> deserialise()
identical(iris, iris2)
# and:
iris3 <- iris |> serialise() |> encrypt() |> decrypt() |> deserialise()
identical(iris, iris3)

# a serialised object is a representation for any type of data
serialise(iris)[1:25]

# and can be converted back at any time
iris |> serialise() |> deserialise() |> head()


# POSTING DATA ---------------------------------------------------------

# post_data() sends data using POST, after serialising (and encrypting)

\dontrun{

post_data(iris,
          url = "https://some-server:8000/post",
          compress = TRUE,
          encrypt = TRUE)
}

# use create_json_body() to make an encrypted JSON of an object, and
# read_json_body() to read it back
iris_json <- iris |> create_json_body(compress = TRUE, encrypt = TRUE)
# (can be sent securely to a server)
# then:
iris4 <- iris_json |> read_json_body(decompress = TRUE, decrypt = TRUE)
identical(iris, iris4)

# equivalent using curl:
# curl -X POST https://some-server:8000/post
#      -H "Content-Type: application/json"
#      -d '...'

# replace the "..." with the outcome of create_json_body():
iris_json
}
